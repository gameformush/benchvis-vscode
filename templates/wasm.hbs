<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="mobile-web-app-capable" content="yes">
	<meta http-equiv="Content-Security-Policy"
		content="default-src 'none'; connect-src {{{cspSource}}}; img-src {{{cspSource}}}; style-src {{{cspSource}}} 'unsafe-inline'; script-src 'nonce-{{nonce}}' 'unsafe-eval'; worker-src blob:;">

	<script nonce="{{nonce}}" src="{{{wasmjs}}}"></script>
	<title>Benchmark Visualization</title>
	<script nonce="{{nonce}}" src="{{chartJsUri}}"></script>
	<style>
		body {
			font-family: var(--vscode-font-family);
			color: var(--vscode-foreground);
			background-color: var(--vscode-editor-background);
			padding: 20px;
			margin: 0;
		}

		h1,
		h2 {
			color: var(--vscode-editor-foreground);
		}

		.metadata {
			margin-bottom: 20px;
			padding: 10px;
			background-color: var(--vscode-editor-inactiveSelectionBackground);
			border-radius: 5px;
		}

		.controls {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			margin-bottom: 20px;
			padding: 15px;
			background-color: var(--vscode-editor-inactiveSelectionBackground);
			border-radius: 5px;
		}

		.control-group {
			flex: 1;
			min-width: 200px;
		}

		.control-group h3 {
			margin-top: 0;
		}

		label {
			display: block;
			margin-bottom: 5px;
		}

		select,
		input[type="color"] {
			width: 100%;
			padding: 8px;
			margin-bottom: 10px;
			background-color: var(--vscode-input-background);
			color: var(--vscode-input-foreground);
			border: 1px solid var(--vscode-input-border);
			border-radius: 3px;
		}

		button {
			background-color: var(--vscode-button-background);
			color: var(--vscode-button-foreground);
			border: none;
			padding: 8px 16px;
			border-radius: 3px;
			cursor: pointer;
			margin-top: 10px;
		}

		button:hover {
			background-color: var(--vscode-button-hoverBackground);
		}

		.benchmark-list {
			max-height: 200px;
			overflow-y: auto;
			padding: 5px;
			background-color: var(--vscode-input-background);
			border: 1px solid var(--vscode-input-border);
			border-radius: 3px;
		}

		.benchmark-item {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
		}

		.benchmark-item input {
			margin-right: 8px;
		}

		.chart-container {
			position: relative;
			height: 400px;
			margin-top: 20px;
			padding: 15px;
			background-color: var(--vscode-editor-inactiveSelectionBackground);
			border-radius: 5px;
		}

		.color-palette {
			display: flex;
			gap: 10px;
			margin-bottom: 10px;
		}

		.palette {
			cursor: pointer;
			display: flex;
			width: 100px;
			height: 20px;
			border-radius: 3px;
			overflow: hidden;
		}

		.palette-color {
			flex: 1;
			height: 100%;
		}

		.palette.selected {
			outline: 2px solid var(--vscode-focusBorder);
		}

		.custom-colors {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			margin-top: 10px;
		}

		.color-input {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
		}

		.color-input input {
			margin-right: 5px;
			width: 50px;
		}

		.tooltip {
			background-color: var(--vscode-editor-background);
			border: 1px solid var(--vscode-input-border);
			padding: 10px;
			border-radius: 5px;
			box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
		}
		
		.error-message {
			color: var(--vscode-errorForeground);
			background-color: var(--vscode-inputValidation-errorBackground);
			border: 1px solid var(--vscode-inputValidation-errorBorder);
			padding: 10px;
			margin: 10px 0;
			border-radius: 5px;
		}
	</style>
</head>

<body>
	<h1>Benchmark Visualization</h1>
	
	<div id="error-container"></div>
	
	<div class="controls">
		<div class="control-group">
			<h3>Benchmarks</h3>
			<div id="benchmark-list" class="benchmark-list">
				<!-- Benchmarks will be populated here -->
			</div>
		</div>
		
		<div class="control-group">
			<h3>Metrics</h3>
			<label for="metric-select">Metric:</label>
			<select id="metric-select">
				<!-- Metrics will be populated here -->
			</select>
			
			<label for="chart-type">Chart Type:</label>
			<select id="chart-type">
				<option value="bar">Bar Chart</option>
				<option value="line">Line Chart</option>
				<option value="radar">Radar Chart</option>
				<option value="polarArea">Polar Area</option>
				<option value="doughnut">Doughnut</option>
			</select>
		</div>
		
		<div class="control-group">
			<h3>Colors</h3>
			<div class="color-palette">
				<div class="palette selected" data-palette="default">
					<div class="palette-color" style="background-color: #4285F4"></div>
					<div class="palette-color" style="background-color: #EA4335"></div>
					<div class="palette-color" style="background-color: #FBBC05"></div>
					<div class="palette-color" style="background-color: #34A853"></div>
				</div>
				<div class="palette" data-palette="pastel">
					<div class="palette-color" style="background-color: #ff9aa2"></div>
					<div class="palette-color" style="background-color: #c7ceea"></div>
					<div class="palette-color" style="background-color: #b5ead7"></div>
					<div class="palette-color" style="background-color: #ffdac1"></div>
				</div>
			</div>
			<div id="custom-colors" class="custom-colors">
				<!-- Color inputs will be populated here -->
			</div>
		</div>
	</div>
	
	<div class="chart-container">
		<canvas id="benchmarkChart"></canvas>
	</div>

	<script nonce="{{nonce}}">
		// Store color palettes
		const colorPalettes = {
			default: ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#0097A7', '#00C853', '#FF6D00'],
			pastel: ['#ff9aa2', '#c7ceea', '#b5ead7', '#ffdac1', '#e2f0cb', '#c5a3ff', '#9de3d0', '#f6c3b7']
		};
		
		let selectedPalette = 'default';
		let customColors = [...colorPalettes.default];
		
		// Initialize chart
		let benchmarkChart = null;
		let benchmarkResults = [];
		
		// Check if Chart.js is available
		window.addEventListener('load', function() {
			if (typeof Chart === 'undefined') {
				showError("Chart.js library is not loaded. Unable to display visualization.");
				console.error("Chart.js is not defined");
			} else {
				console.log("Chart.js is loaded successfully");
			}
		});
		
		// Show error message
		function showError(message) {
			const errorContainer = document.getElementById('error-container');
			const errorDiv = document.createElement('div');
			errorDiv.className = 'error-message';
			errorDiv.textContent = message;
			errorContainer.innerHTML = '';
			errorContainer.appendChild(errorDiv);
		}
		
		// Helper function to set alpha of a color
		function setAlpha(color, alpha) {
			if (color.startsWith('#')) {
				const r = parseInt(color.slice(1, 3), 16);
				const g = parseInt(color.slice(3, 5), 16);
				const b = parseInt(color.slice(5, 7), 16);
				return `rgba(${r}, ${g}, ${b}, ${alpha})`;
			}
			return color;
		}
		
		// Helper function to format metric values
		function formatMetricValue(value, metric) {
			if (metric === 'sec/op') {
				if (value < 0.000001) {
					return `${(value * 1000000000).toFixed(2)} ns/op`;
				} else if (value < 0.001) {
					return `${(value * 1000000).toFixed(2)} Âµs/op`;
				} else if (value < 1) {
					return `${(value * 1000).toFixed(2)} ms/op`;
				} else {
					return `${value.toFixed(4)} sec/op`;
				}
			} else if (metric === 'B/op') {
				if (value > 1048576) {
					return `${(value / 1048576).toFixed(2)} MB/op`;
				} else if (value > 1024) {
					return `${(value / 1024).toFixed(2)} KB/op`;
				} else {
					return `${value.toFixed(2)} B/op`;
				}
			} else if (metric === 'allocs/op') {
				return `${value} allocs/op`;
			} else if (metric === 'size') {
				return `${value} bytes`;
			} else {
				// For decimal values, round to 2 decimal places
				if (Math.floor(value) !== value) {
					return value.toFixed(2) + ' ' + metric;
				}
				
				// Default formatting
				return `${value} ${metric}`;
			}
		}
		
		// Update custom color inputs
		function updateCustomColorInputs() {
			const container = document.getElementById('custom-colors');
			container.innerHTML = '';
			
			// Get selected benchmarks and create color inputs for each
			const checkboxes = document.querySelectorAll('.benchmark-checkbox:checked');
			Array.from(checkboxes).forEach((checkbox, index) => {
				const name = checkbox.nextElementSibling.textContent;
				const colorIndex = index % customColors.length;
				
				const colorInput = document.createElement('div');
				colorInput.className = 'color-input';
				colorInput.innerHTML = `
					<input type="color" data-index="${index}" value="${customColors[colorIndex]}">
					<span>${name}</span>
				`;
				
				container.appendChild(colorInput);
			});
			
			// Add event listeners to color inputs
			document.querySelectorAll('#custom-colors input[type="color"]').forEach(input => {
				input.addEventListener('change', (event) => {
					const index = parseInt(event.target.dataset.index);
					customColors[index % customColors.length] = event.target.value;
					try {
						updateChart(benchmarkResults);
					} catch (error) {
						showError(`Error updating chart: ${error.message}`);
						console.error(error);
					}
				});
			});
		}
		
		// Acquire VS Code API
		const vscode = acquireVsCodeApi();
		
		// WASM Setup
		const WASM_URL = '{{{WASM_URL}}}';
		let wasm;
		
		function init() {
			const go = new Go();
			if ('instantiateStreaming' in WebAssembly) {
				WebAssembly.instantiateStreaming(fetch(WASM_URL), go.importObject).then(function (obj) {
					wasm = obj.instance;
					go.run(wasm);
					console.log("WASM loaded");
					vscode.postMessage({ command: 'loaded' });
				}).catch(error => {
					showError(`Error loading WASM: ${error.message}`);
					console.error("WASM loading error:", error);
				})
			} else {
				fetch(WASM_URL).then(resp =>
					resp.arrayBuffer()
				).then(bytes =>
					WebAssembly.instantiate(bytes, go.importObject).then(function (obj) {
						wasm = obj.instance;
						go.run(wasm);
						console.log("WASM loaded");
						vscode.postMessage({ command: 'loaded' });
					})
				).catch(error => {
					showError(`Error loading WASM: ${error.message}`);
					console.error("WASM loading error:", error);
				})
			}
		}
		
		init();
		
		// Helper function to format metric names for display
		function formatMetricName(metricName) {
			switch (metricName) {
				case 'sec/op': return 'Time (sec/op)';
				case 'ns/op': return 'Time (ns/op)';
				case 'B/op': return 'Memory (B/op)';
				case 'allocs/op': return 'Allocations (allocs/op)';
				case 'size': return 'Size (bytes)';
				default:
					// Format custom metrics
					return metricName
						.replace(/_/g, ' ')
						.replace(/\//g, ' per ')
						.replace(/\b\w/g, c => c.toUpperCase());
			}
		}
		
		// Get metric value from a benchmark result
		function getResultMetricValue(result, metricName) {
			if (!result || !result.values || !Array.isArray(result.values)) {
				return null;
			}
			
			const metric = result.values.find(v => v && v.unit === metricName);
			return metric ? metric.value : null;
		}
		
		// Get selected benchmarks from the UI
		function getSelectedBenchmarks(results) {
			if (!results || !Array.isArray(results)) {
				return [];
			}
			
			const checkboxes = document.querySelectorAll('.benchmark-checkbox:checked');
			const selectedNames = Array.from(checkboxes).map(checkbox => 
				checkbox.nextElementSibling.textContent);
			
			return results.filter(result => result && selectedNames.includes(result.name));
		}
		
		// Process benchmark results and prepare data for visualization
		function processBenchmarkResults(results) {
			try {
				// Clear any previous errors
				document.getElementById('error-container').innerHTML = '';
				
				if (!results) {
					showError("No benchmark results returned from WASM function");
					console.error("No results from parseBenchmarkFiles");
					return;
				}
				
				if (!Array.isArray(results)) {
					showError("Invalid benchmark results format: not an array");
					console.error("Results is not an array:", results);
					return;
				}
				
				if (results.length === 0) {
					showError("No benchmark results found in data");
					console.error("Empty results array");
					return;
				}
				
				// Check if Chart.js is available
				if (typeof Chart === 'undefined') {
					showError("Chart.js library is not loaded. Unable to display visualization.");
					console.error("Chart.js is not defined");
					return;
				}
				
				benchmarkResults = results;
				console.log("Processing benchmark results:", results);
				
				// Extract available metrics from results
				const availableMetrics = [];
				let metricsFound = false;
				
				// Look through all results for metrics
				for (let i = 0; i < results.length; i++) {
					const result = results[i];
					if (result && Array.isArray(result.values) && result.values.length > 0) {
						result.values.forEach(value => {
							if (value && value.unit) {
								// Check if this metric is already in our list
								if (!availableMetrics.some(m => m.name === value.unit)) {
									availableMetrics.push({
										name: value.unit,
										displayName: formatMetricName(value.unit),
										originalUnit: value.orig_unit || value.unit
									});
								}
							}
						});
						metricsFound = true;
					}
				}
				
				if (!metricsFound) {
					showError("No valid metrics found in benchmark results");
					console.error("No valid metrics in results");
					return;
				}
				
				// Populate metric selection dropdown
				const metricSelect = document.getElementById('metric-select');
				metricSelect.innerHTML = '';
				availableMetrics.forEach(metric => {
					const option = document.createElement('option');
					option.value = metric.name;
					option.textContent = metric.displayName;
					metricSelect.appendChild(option);
				});
				
				// Create benchmark list for selection
				const benchmarkList = document.getElementById('benchmark-list');
				benchmarkList.innerHTML = '';
				
				// Group results by name to avoid duplicates in the list
				const benchmarkNames = new Set();
				results.forEach(result => {
					if (result && result.name) {
						benchmarkNames.add(result.name);
					}
				});
				
				if (benchmarkNames.size === 0) {
					showError("No valid benchmark names found in results");
					console.error("No valid benchmark names");
					return;
				}
				
				// Add benchmarks to list
				Array.from(benchmarkNames).sort().forEach((name, index) => {
					const item = document.createElement('div');
					item.className = 'benchmark-item';
					
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.className = 'benchmark-checkbox';
					checkbox.dataset.index = index;
					checkbox.checked = true; // Default to checked
					
					const label = document.createElement('label');
					label.textContent = name;
					
					item.appendChild(checkbox);
					item.appendChild(label);
					benchmarkList.appendChild(item);
				});
				
				// Add event listeners to checkboxes
				document.querySelectorAll('.benchmark-checkbox').forEach(checkbox => {
					checkbox.addEventListener('change', () => {
						try {
							updateCustomColorInputs();
							updateChart(results);
						} catch (error) {
							showError(`Error updating chart: ${error.message}`);
							console.error(error);
						}
					});
				});
				
				// Update metric selection event listener
				document.getElementById('metric-select').addEventListener('change', () => {
					try {
						updateChart(results);
					} catch (error) {
						showError(`Error updating chart: ${error.message}`);
						console.error(error);
					}
				});
				
				document.getElementById('chart-type').addEventListener('change', () => {
					try {
						updateChart(results);
					} catch (error) {
						showError(`Error updating chart: ${error.message}`);
						console.error(error);
					}
				});
				
				// Setup color palette selection
				document.querySelectorAll('.palette').forEach(palette => {
					palette.addEventListener('click', (event) => {
						try {
							const paletteElement = event.target.closest('.palette');
							if (paletteElement) {
								const paletteName = paletteElement.dataset.palette;
								selectedPalette = paletteName;
								customColors = [...colorPalettes[paletteName]];
								
								// Update selected palette UI
								document.querySelectorAll('.palette').forEach(p => {
									p.classList.remove('selected');
								});
								paletteElement.classList.add('selected');
								
								updateCustomColorInputs();
								updateChart(results);
							}
						} catch (error) {
							showError(`Error updating palette: ${error.message}`);
							console.error(error);
						}
					});
				});
				
				// Initialize chart
				updateCustomColorInputs();
				updateChart(results);
			} catch (error) {
				showError(`Error processing benchmark results: ${error.message}`);
				console.error("Error in processBenchmarkResults:", error);
			}
		}
		
		// Update chart with benchmark results
		function updateChart(results) {
			try {
				// Check if Chart.js is loaded
				if (typeof Chart === 'undefined') {
					showError("Chart.js library is not loaded. Unable to display visualization.");
					console.error("Chart.js is not defined");
					return;
				}
				
				if (!results || !Array.isArray(results) || results.length === 0) {
					showError("No valid benchmark results to visualize");
					return;
				}
				
				const selectedBenchmarks = getSelectedBenchmarks(results);
				const selectedMetric = document.getElementById('metric-select').value;
				const chartType = document.getElementById('chart-type').value;
				
				if (selectedBenchmarks.length === 0) {
					console.warn("No benchmarks selected");
					return;
				}
				
				if (!selectedMetric) {
					console.warn("No metric selected");
					return;
				}
				
				// Prepare chart data
				const datasets = [];
				const benchmarkNamesSet = new Set();
				
				// Group by benchmark name
				const benchmarksByName = {};
				selectedBenchmarks.forEach(benchmark => {
					if (benchmark && benchmark.name) {
						if (!benchmarksByName[benchmark.name]) {
							benchmarksByName[benchmark.name] = [];
							benchmarkNamesSet.add(benchmark.name);
						}
						benchmarksByName[benchmark.name].push(benchmark);
					}
				});
				
				if (benchmarkNamesSet.size === 0) {
					console.warn("No valid benchmark names found");
					return;
				}
				
				// Create a dataset for each unique benchmark name
				const benchmarkNames = Array.from(benchmarkNamesSet).sort();
				benchmarkNames.forEach((name, index) => {
					const benchmarks = benchmarksByName[name];
					if (!benchmarks || benchmarks.length === 0) return;
					
					// Get values for this benchmark
					const dataPoints = benchmarks.map(benchmark => 
						getResultMetricValue(benchmark, selectedMetric));
					
					// Only add dataset if we have valid data
					if (dataPoints.some(value => value !== null)) {
						// Get color for this benchmark
						const colorIndex = index % customColors.length;
						const baseColor = customColors[colorIndex];
						
						// Create dataset
						const dataset = {
							label: name,
							data: dataPoints,
							backgroundColor: setAlpha(baseColor, 0.5),
							borderColor: baseColor,
							borderWidth: 1,
							hoverBackgroundColor: setAlpha(baseColor, 0.7),
							hoverBorderColor: baseColor,
							pointBackgroundColor: baseColor,
							pointBorderColor: '#fff',
							pointHoverBackgroundColor: '#fff',
							pointHoverBorderColor: baseColor
						};
						
						datasets.push(dataset);
					}
				});
				
				if (datasets.length === 0) {
					console.warn("No datasets created - no valid data for selected metric");
					return;
				}
				
				// Determine chart labels based on benchmark configurations
				let chartLabels = [];
				
				if (selectedBenchmarks.length > 0) {
					// Try to find a good differentiating key in the config
					const configKeys = new Set();
					selectedBenchmarks.forEach(benchmark => {
						if (benchmark && benchmark.config && Array.isArray(benchmark.config)) {
							benchmark.config.forEach(cfg => {
								if (cfg && cfg.key) {
									configKeys.add(cfg.key);
								}
							});
						}
					});
					
					// If we have configs, try to use them as labels
					if (configKeys.size > 0) {
						// Find keys that have different values across benchmarks
						const differentiatingKeys = Array.from(configKeys).filter(key => {
							const values = new Set();
							selectedBenchmarks.forEach(benchmark => {
								if (benchmark && benchmark.config && Array.isArray(benchmark.config)) {
									const config = benchmark.config.find(cfg => cfg && cfg.key === key);
									if (config && config.value) {
										values.add(config.value);
									}
								}
							});
							return values.size > 1;
						});
						
						if (differentiatingKeys.length > 0) {
							// Use the first differentiating key
							const key = differentiatingKeys[0];
							chartLabels = selectedBenchmarks.map(benchmark => {
								if (benchmark && benchmark.config && Array.isArray(benchmark.config)) {
									const config = benchmark.config.find(cfg => cfg && cfg.key === key);
									return config && config.value ? `${key}: ${config.value}` : 'Unknown';
								}
								return 'Unknown';
							});
						}
					}
				}
				
				// If we couldn't determine labels from config, use benchmark names or indices
				if (chartLabels.length === 0) {
					if (chartType === 'bar' || chartType === 'line') {
						chartLabels = benchmarkNames;
					} else {
						// For other chart types, use indices
						chartLabels = selectedBenchmarks.map((_, i) => `Run ${i + 1}`);
					}
				}
				
				// Make sure chartLabels has same length as data if we have datasets
				if (datasets.length > 0 && datasets[0].data && datasets[0].data.length > 0) {
					while (chartLabels.length < datasets[0].data.length) {
						chartLabels.push(`Item ${chartLabels.length + 1}`);
					}
				}
				
				// Prepare chart configuration
				const chartConfig = {
					type: chartType,
					data: {
						labels: chartLabels,
						datasets: datasets
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						scales: {
							y: {
								beginAtZero: true,
								title: {
									display: true,
									text: formatMetricName(selectedMetric)
								}
							},
							x: {
								title: {
									display: true,
									text: 'Benchmark'
								}
							}
						},
						plugins: {
							tooltip: {
								callbacks: {
									label: function(context) {
										let label = context.dataset.label || '';
										if (label) {
											label += ': ';
										}
										if (context.parsed.y !== null) {
											label += formatMetricValue(context.parsed.y, selectedMetric);
										}
										return label;
									}
								}
							},
							legend: {
								position: 'top'
							},
							title: {
								display: true,
								text: `Benchmark Results - ${formatMetricName(selectedMetric)}`
							}
						}
					}
				};
				
				// Create or update the chart
				try {
					const ctx = document.getElementById('benchmarkChart').getContext('2d');
					
					if (benchmarkChart) {
						benchmarkChart.destroy();
					}
					
					benchmarkChart = new Chart(ctx, chartConfig);
					
					// Send message to the extension with the selected options
					vscode.postMessage({
						command: 'updateVisualization',
						selectedBenchmarks: benchmarkNames,
						selectedMetric,
						chartType
					});
				} catch (chartError) {
					showError(`Failed to create chart: ${chartError.message}`);
					console.error("Chart creation error:", chartError);
				}
			} catch (error) {
				showError(`Error creating chart: ${error.message}`);
				console.error("Error in updateChart:", error);
			}
		}
		
		// Handle messages from the extension
		window.addEventListener("message", (event) => {
			try {
				console.log("Received message:", event.data);
				switch (event.data?.command) {
					case 'parseBenchmark':
						console.log("Parsing benchmark data:", event.data.data);
						try {
							if (!event.data.data) {
								showError("No benchmark data provided");
								return;
							}
							
							let dataToProcess;
							
							// Check if data is a string or an object with data property
							if (typeof event.data.data === 'string') {
								dataToProcess = event.data.data;
							} else if (event.data.data && typeof event.data.data.data === 'string') {
								// The data is nested in a data property
								dataToProcess = event.data.data.data;
							} else {
								// Otherwise try to stringify it
								dataToProcess = JSON.stringify(event.data.data);
							}
							
							// If dataToProcess is already a string that looks like JSON, don't stringify it again
							const jsonData = typeof dataToProcess === 'string' && 
								(dataToProcess.startsWith('[') || dataToProcess.startsWith('{')) ?
								dataToProcess : JSON.stringify(dataToProcess);
							
							console.log("JSON data for parsing:", jsonData.substring(0, 100) + "...");
							
							try {
								const results = parseBenchmarkFiles(jsonData);
								console.log("Parsed benchmark results:", results);
								
								if (typeof results === 'object' && results !== null && results.data) {
									// Handle WASM response format with data and error properties
									if (results.error) {
										showError(`WASM parsing error: ${results.error}`);
										return;
									}
									
									try {
										const parsedData = JSON.parse(results.data);
										processBenchmarkResults(parsedData);
									} catch (parseError) {
										showError(`Error parsing WASM results data: ${parseError.message}`);
										console.error("JSON parse error:", parseError);
									}
								} else {
									// Direct array result
									processBenchmarkResults(results);
								}
							} catch (wasmError) {
								showError(`WASM function error: ${wasmError.message}`);
								console.error("WASM error:", wasmError);
							}
						} catch (error) {
							showError(`Error parsing benchmark data: ${error.message}`);
							console.error("Error in parseBenchmarkFiles:", error);
						}
						break;
					default:
						console.warn(`Unknown command: ${event.data?.command}`);
				}
			} catch (error) {
				showError(`Error processing message: ${error.message}`);
				console.error("Error processing message:", error);
			}
		});
	</script>
</body>

</html>